# CLR

## 概念
* Common Language Runtime，公共语言运行时，.NET框架的核心部分，为.NET框架之上的各种语言提供运行时环境（对应Java中的JVM）

## 一、基础知识点

### 1.1 托管模块（managed module）
* 任何支持CLR的语言都会通过编译器将代码编译成托管模块（managed module），即PE32或PE32+文件。托管程序利用DEP（Data Execution Prevention）和ASLR（Address Space Layout Randomization）对系统安全性进行保护。

* 托管模块的组成部分：
 - PE32或PE32+头
 - CLR头：Main方法的MethodDef token
 - 元数据（metadata）：与相应的模块IL代码同步绑定的描述文件，描述模块中定义了什么、引用了什么
 - IL代码：CLR运行时编译成本机CPU指令，JIT机制。也称为托管代码（managed code）

* 元数据：
 - CLR使用元数据确保代码只执行“类型安全”的操作
 - 元数据允许将对象实例序列化、反序列化来重建对象状态
 - 元数据允许垃圾回收器跟踪对象生命周期

* 有且仅有C++编译器会生成非托管（native）代码模块，这些模块可以脱离CLR直接执行。可以通过编译开关来决定是否由C++编译器生成托管代码。C++在.NET中有着不同的地位，托管代码中可以直接使用原生的C++代码，并在运行时替换为托管类型。

### 1.2 程序集（Assembly）
* 程序集是模块/资源文件的逻辑性分组，相当于“组件”的概念。
* 程序集使一组文件可作为一个单独的实体来对待
* 事实上编译器生成的是带有清单（manifest）的程序集，而不仅仅是IL代码
* 对于含有多个文件的程序集，需要使用AL等工具进行程序集链接
* 程序集是自描述（self-describing）的

### 1.3 CLR加载
* x86、x64和ARM不同平台的生成文件的文件头有差异，使其在不同平台上的表现不同，使用/platform编译开关进行修改
* 32位程序在64位操作系统中将以WoW64应用程序运行
* CLR事实上是MSCorEE.dll，根据具体文件头加载到进程的地址空间中
* 运行程序时，先加载MSCorEE.dll并运行MSCorEE.dll中的初始化方法初始化CLR，之后加载EXE程序集并调用Main入口
* 非托管代码使用LoadLibrary加载托管程序集时，Windows会自动加载初始化CLR，但64位非托管进程无法加载x86编译开关下编译的托管程序集

### 1.4 程序集执行
* CLR上执行的是IL代码，IL代码可以看做是面向对象的机器语言
* Windows提供了ILAsm和ILDasm两个程序来进行IL和汇编语言的相互转换
* 通过IL，提供了.NET平台多语言的无缝集成开发能力，而且由于每种高级语言只实现了CLR的一部分功能，迫切需要的功能可以直接通过修改IL代码来实现，因为IL语言可以访问CLR的所有功能
* CLR运行时使用JIT（just-in-time，即时）编译器将IL语言转换成本机（native）CPU指令，其过程为：
 - CLR会在运行前检测代码使用的所有引用类型，并分配内部结构来管理这些类型，类型中包含其将使用的所有方法
 - 初始时，每个方法均指向MSCorEE.dll中的一个未编档函数
 - 第一次调用时，MSCorEE.dll中的函数会根据具体方法查找元数据、验证IL代码、分配内存、JIT编译、并修改管理类型中的方法指向新的本地代码段
 - 之后调用方法，则由于方法已经指向本地代码段而无需再次编译，即JIT编译仅发生在第一次调用时
* 由于每次重新运行时均需要进行JIT编译，所以本地程序的只读代码段将由所有运行实例共享
* .NET两次编译是否优化可以通过编译开关来设置
 - /optimize编译开关：/optimize-，则编译成IL代码时不做优化，将包含许多NOP或跳转到下一行的指令，这些指令主要用于断点设置，提供了编辑并继续（edit-and-continue）功能。/optimize+则开启IL编译优化，会去除多余的NOP和跳转指令，会导致不易单步调试，而且可能导致调试器中函数失效，但代码更精炼，更高效，且更易读。
 - /debug编译开关：/debug:(+/-/full/pdbonly)决定JIT编译器在执行是是否生成PDB（Program Database）文件关联IL指令和源代码，以及打开full开关，则每条IL指令会关联本机汇编语言，以支持更方便的调试，VS开发调试时debug始终为full。
 - 打开优化编译开关，可以提升代码运行速度，减少代码的内存损耗
 - VS默认配置：Debug环境下为/optimize-,/debug:full，Release环境下为/optimize+,/debug:pdbonly
* 虽然JIT看起来消耗了更多的CPU和内存，但是其实际运行效率可能比非托管代码更高，因为JIT可以根据具体运行的CPU平台进行特殊优化，而C++的非托管编译器则是针对最小功能集的CPU编译，不会使用特定CPU平台的特殊性能提升指令。而且由于是二次编译，CLR对IL的评估将更加准确，可以进一步提高分支预测的正确性。
* 可以使用NGen.exe工具预编译IL到机器代码并存储，这样CLR将使用预编译版本而不再使用JIT进行即时编译，但NGen的优化比JIT要保守很多。
* 也可以使用System.Runtime.ProfileOptimization类，该类可以导致特定方法在程序初始化时多线程并发编译，而非JIT编译，以保证方法的效率。
* IL基于栈执行，指令通过对栈的push和pop执行，且IL指令是无类型（typeless）的，指令执行时根据栈中操作数的类型决定操作行为。










